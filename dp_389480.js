function solution(info, n, m) {
  var answer = 0;
  //n * m의 배열을 만든다.
  //최대의 경우에 수에 대한 2차원 배열을 만든다.
  const dp = Array.from(Array(n), () => new Array(m).fill(false));
  console.log(dp);
  dp[0][0] = true; //시작은 해야하니

  // 작은 부분 문제부터 차례대로 해결한다. ?
  // a도둑이 적게 훔쳐야하므로 최대한 b도둑이 훔쳐야한다.
  // 따라서 a도둑이 훔쳤을 때 결과값, b도둑이 훔쳣을때 결과값 등을 저장해야한다.
  // dp는 문제의 결과를 저장하고 재사용하여 중복계산을 피하고 효율적으로 문제해결.
  // a가 훔치거나 b가 훔치거나. 방법이 두개이다.
  // but dfs의 경우에는 어제 끝날 지 모른다.
  // 그리고 그 다음 선택지가 정해져있지 않아서 깊은 탐색을 하는것

  //점화식
  for (let i = 0; i < info.length; i++) {
    //물건 결과 저장 dp배열 생성
    console.log(i);
    const nextDp = new Array(n).fill(Array(m).fill(false));
  }

  return answer;
}

/**
 * a도둑이 훔치면 info[i][0]만큼, b도둑이 훔치면 info[i][1]만큼 훔친다.
 * n개만큼
 * m만큼 훔칠 수 있다.
 * A가 남기는 흔적의 최솟값
 * 어떤 경로로도 훔칠 수 없다면 -1을 리턴
 */

//2
solution(
  [
    [1, 2],
    [2, 3],
    [2, 1],
  ],
  4,
  4
);

// //0
// solution(
//   [
//     [1, 2],
//     [2, 3],
//     [2, 1],
//   ],
//   1,
//   7
// );

// 0;
// solution(
//   [
//     [3, 3],
//     [3, 3],
//   ],
//   7,
//   1
// );

// //-1
// solution(
//   [
//     [3, 3],
//     [3, 3],
//   ],
//   6,
//   1
// );
